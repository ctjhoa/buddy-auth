<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>User Guide</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">buddy-auth</span> <span class="project-version">3.0.1</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="user-guide.html"><div class="inner"><span>User Guide</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>buddy</span></div></div></li><li class="depth-2"><a href="buddy.auth.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>auth</span></div></a></li><li class="depth-3 branch"><a href="buddy.auth.accessrules.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>accessrules</span></div></a></li><li class="depth-3"><a href="buddy.auth.backends.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>backends</span></div></a></li><li class="depth-4 branch"><a href="buddy.auth.backends.httpbasic.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>httpbasic</span></div></a></li><li class="depth-4 branch"><a href="buddy.auth.backends.session.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>session</span></div></a></li><li class="depth-4"><a href="buddy.auth.backends.token.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>token</span></div></a></li><li class="depth-3 branch"><a href="buddy.auth.http.html"><div class="inner"><span class="tree" style="top: -114px;"><span class="top" style="height: 123px;"></span><span class="bottom"></span></span><span>http</span></div></a></li><li class="depth-3 branch"><a href="buddy.auth.middleware.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>middleware</span></div></a></li><li class="depth-3"><a href="buddy.auth.protocols.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>protocols</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#user-guide" name="user-guide"></a>User Guide</h1>
<h2><a href="#introduction" name="introduction"></a>Introduction</h2>
<p><em>buddy-auth</em> is a module that provides authentication and authorization facilites for ring and ring based web applications.</p>
<h3><a href="#project-maturity" name="project-maturity"></a>Project Maturity</h3>
<p>Since <em>buddy-auth</em> is in a maintenance mode and does not expect more changes.</p>
<h3><a href="#install" name="install"></a>Install</h3>
<p>The simplest way to use <em>buddy-auth</em> in a clojure project is by including it in your <em><em>project.clj</em></em> dependency vector:</p>
<pre><code class="clojure">{buddy/buddy-auth {:mvn/version "3.0.1"}
</code></pre>
<p>This package is intended to be used with <em>jdk7</em> or <em>jdk8</em>.</p>
<h2><a href="#authentication" name="authentication"></a>Authentication</h2>
<h3><a href="#introduction" name="introduction"></a>Introduction</h3>
<p>The buddy’s approach for authentication is pretty simple and explicit. In contrast to the vast majority of authentication libraries that I know, <em>buddy</em> does not mix authentication process with the authorization.</p>
<p>It is implemented as a pluggable backend that can be picked as is or you can implement a new one with simple steps. This is a list of builtin backends:</p>
<table>
  <thead>
    <tr>
      <th>Backend name </th>
      <th>Namespace </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Http Basic </td>
      <td><code>buddy.auth.backends/basic</code> </td>
    </tr>
    <tr>
      <td>Session </td>
      <td><code>buddy.auth.backends/session</code> </td>
    </tr>
    <tr>
      <td>Token </td>
      <td><code>buddy.auth.backends/token</code> </td>
    </tr>
    <tr>
      <td>Signed JWT </td>
      <td><code>buddy.auth.backends/jws</code> </td>
    </tr>
    <tr>
      <td>Encrypted JWT </td>
      <td><code>buddy.auth.backends/jwe</code> </td>
    </tr>
  </tbody>
</table>
<p>If you are not happy with the built-in backends, you can implement your own and use it with <em>buddy-auth</em> middleware without any problems.</p>
<p>The authentication process works mainly in two steps:</p>
<ol>
  <li><em>parse</em>: that is responsible for analyzing the request and read the auth  related data (e.g. <code>Authorization</code> header, url params, etc..)</li>
  <li><em>auth</em>: with the data obtained from parse step just try to authenticate the  the request (e.g. simple access to database for obtain the possible user,  using a self contained jws/jwe token, check a key in the session, etc…)</li>
</ol>
<p>This step does not raise any exceptions and is completely transparent to the user. The authentication process responsibility is to determine if a request is anonymous or is authenticated, nothing more.</p>
<h3><a href="#backends" name="backends"></a>Backends</h3>
<h4><a href="#http-basic" name="http-basic"></a>Http-Basic</h4>
<p>The HTTP Basic authentication backend is one of the simplest and most insecure authentication systems, but is a good first step to understanding how <em>buddy-auth</em> authentication works.</p>
<pre><code class="clojure">(require '[ring.util.response :refer (response)])

;; Simple ring handler. This can also be a compojure router handler
;; or anything else compatible with ring middleware.

(defn my-handler
  [request]
  (if (:identity request)
    (response (format "Hello %s" (:identity request)))
    (response "Hello Anonymous")))
</code></pre>
<p>The basic step to check if a request is authenticated or not, is just to check if it comes with an <code>:identity</code> key and it contains a logical <code>true</code> (exists and contains something different to <code>nil</code> or <code>false</code>).</p>
<p>This is how the authentication backend should be setup:</p>
<pre><code class="clojure">(require '[buddy.auth.backends :as backends])

(defn my-authfn
  [request authdata]
  (let [username (:username authdata)
        password (:password authdata)]
    username))

(def backend (backends/basic {:realm "MyApi"
                              :authfn my-authfn}))
</code></pre>
<p>The <code>authfn</code> is responsible for the second step of authentication. It receives the parsed auth data from request and should return a logical true value (e.g a user id, user instance, mainly something different to <code>nil</code> and <code>false</code>). And it will be called only if step 1 (parse) returns something.</p>
<p>And finally, you should wrap your ring handler with authentication and authorization middleware:</p>
<pre><code class="clojure">(require '[buddy.auth.middleware :refer [wrap-authentication
                                         wrap-authorization]])

;; Define the main handler with *app* name wrapping it
;; with authentication middleware using an instance of the
;; just created http-basic backend.

;; Define app var with handler wrapped with _buddy-auth_'s authentication
;; and authorization middleware using the previously defined backend.

(def app (-&gt; my-handler
             (wrap-authentication backend)
             (wrap-authorization backend)))
</code></pre>
<p>From now, all requests that reach <code>my-handler</code> will be properly authenticated.</p>
<h4><a href="#session" name="session"></a>Session</h4>
<p>The session backend has the simplest implementation because it relies entirely on ring session support.</p>
<p>The authentication process of this backend consists of checking the <code>:identity</code> keyword in session. If it exists and is a logical true, it is automatically forwarded to the request under the <code>:identity</code> property.</p>
<pre><code class="clojure">(require '[buddy.auth.backends :as backends])

;; Create an instance
(def backend (backends/session))

;; Wrap the ring handler.
(def app (-&gt; my-handler
             (wrap-authentication backend)))
</code></pre>
<h4><a href="#token" name="token"></a>Token</h4>
<p>This is a backend that uses tokens for authenticating the user. It behaves very similarly to the basic-auth backend with the difference that instead of authenticating with credentials it authenticates with a simple token.</p>
<p>Let’s see an example:</p>
<pre><code class="clojure">(require '[buddy.auth.backends :as backends])

;; Define a in-memory relation between tokens and users:
(def tokens {:2f904e245c1f5 :admin
             :45c1f5e3f05d0 :foouser})

;; Define an authfn, function with the responsibility
;; to authenticate the incoming token and return an
;; identity instance

(defn my-authfn
  [request token]
  (let [token (keyword token)]
    (get tokens token nil)))

;; Create an instance
(def backend (backends/token {:authfn my-authfn}))

;; Wrap the ring handler.
(def app (-&gt; my-handler
             (wrap-authentication backend)))
</code></pre>
<p>The process of authentication of this backend consists in parsing the “Authorization” header, extracting the token and in case the token is extracted successfully, call the <code>authfn</code> with extracted token.</p>
<pre><code class="clojure">Authorization: Token 45c1f5e3f05d0
</code></pre>
<p>The <code>authfn</code> should return something that will be associated to the <code>:identity</code> key in the request.</p>
<p>The responsability of <em>buddy</em> is just parse request and call the user function authenticate it. The token building and storage is a user responsability.</p>
<p>You can see a complete example of using this backend «example-token,here».</p>
<h4><a href="#signed-jwt" name="signed-jwt"></a>Signed JWT</h4>
<p>Is a backend that uses signed and self contained tokens to authenticate the user.</p>
<p>It behaves very similarly to the <em>Token</em> backend (previously explained) with the difference that this one does not need additional user defined logic to validate tokens, because as we previously said, everything is self contained.</p>
<p>This type of token mechanism enables a complete stateless authentication because the server does not need to store the token and related information, the token will contain all the needed information for authentication.</p>
<p>Let’s see a demonstrative example:</p>
<pre><code>(require '[buddy.auth.backends :as backends])
(require '[buddy.auth.middleware :refer (wrap-authentication)])

(def secret "mysecret")
(def backend (backends/jws {:secret secret}))

;; and wrap your ring application with
;; the authentication middleware

(def app (-&gt; your-ring-app
             (wrap-authentication backend)))
</code></pre>
<p>Now you should have a login endpoint in your ring application that will have the responsibility of generating valid tokens:</p>
<pre><code class="clojure">(require '[buddy.sign.jwt :as jwt])
(require '[cheshire.core :as json])

(defn login-handler
  [request]
  (let [data (:form-params request)
        user (find-user (:username data)   ;; (implementation ommited)
                        (:password data))
        token (jwt/sign {:user (:id user)} secret)]
    {:status 200
     :body (json/encode {:token token})
     :headers {:content-type "application/json"}}))
</code></pre>
<p>For more details about jwt, see the link:<a href="https://funcool.github.io/buddy-sign/latest/#jwt[buddy-sign">https://funcool.github.io/buddy-sign/latest/#jwt[buddy-sign</a>] documentation.</p>
<p>Some valuable resources for learning about stateless authentication are:</p>
<ul>
  <li><a href="http://lucumr.pocoo.org/2013/11/17/my-favorite-database/">http://lucumr.pocoo.org/2013/11/17/my-favorite-database/</a></li>
  <li><a href="http://www.niwi.nz/2014/06/07/stateless-authentication-with-api-rest/">http://www.niwi.nz/2014/06/07/stateless-authentication-with-api-rest/</a></li>
</ul>
<h4><a href="#encrypted-jwt" name="encrypted-jwt"></a>Encrypted JWT</h4>
<p>This backend is almost identical to the previous one (signed JWT).</p>
<p>The main difference is that the backend uses JWE (Json Web Encryption) instead of JWS (Json Web Signature) and it has the advantage that the content of the token is encrypted instead of simply signed. This is useful when token may contain some additional user information that should not be public.</p>
<p>It will look similar to the previous (jws) example but instead using jwe with asymmetric key encryption algorithm:</p>
<pre><code class="clojure">(require '[buddy.auth.backends :as backends])
(require '[buddy.auth.middleware :refer (wrap-authentication)])
(require '[buddy.sign.jwe :as jwe])
(require '[buddy.core.keys :as keys])

(def pubkey (keys/public-key "pubkey.pem"))
(def privkey (keys/private-key "privkey.pem"))

(def backend
  (backends/jwe {:secret privkey
                 :options {:alg :rsa-oaep
                           :enc :a128-hs256}}))

;; and wrap your ring application with
;; the authentication middleware

(def app (-&gt; your-ring-app
             (wrap-authentication backend)))
</code></pre>
<p>The corresponding login endpoint should have a similar aspect to this:</p>
<pre><code class="clojure">(require '[buddy.sign.jwt :as jwt])
(require '[cheshire.core :as json])

(defn login-handler
  [request]
  (let [data (:form-params request)
        user (find-user (:username data)   ;; (implementation ommited)
                        (:password data))
        token (jwt/encrypt {:user (:id user)} pubkey
                           {:alg :rsa-oaep :enc :a128-hs256})]
    {:status 200
     :body (json/encode {:token token})
     :headers {:content-type "application/json"})))
</code></pre>
<p>In order to use any asymmetric encryption algorithm, you should have private/public key pair. If you don’t have one, don’t worry, it is very easy to generate it using <em>openssl</em>, see this link:<a href="https://funcool.github.io/buddy-sign/latest/#generate-keypairs[faq">https://funcool.github.io/buddy-sign/latest/#generate-keypairs[faq</a> entry].</p>
<h2><a href="#authorization" name="authorization"></a>Authorization</h2>
<p>The second part of the auth process is authorization.</p>
<p>The authorization system is split into two parts: generic authorization and access-rules (explained in the next section).</p>
<p>The generic one is based on exceptions, and consists in raising an unauthorized exception in case the request is considered unauthorized. The access rules system is based on some kind of rules attached to the handler or an <em>URI</em> and that rules determine if a request is authorized or not.</p>
<h3><a href="#exception-based" name="exception-based"></a>Exception-Based</h3>
<p>This authorization approach is based on wrapping everything in a try/catch block which only handles specific exceptions. When an unauthorized exception is caught, it executes a specific function to handle it or reraises the exception.</p>
<p>With this approach, you can define your own middlewares/decorators using custom authorization logic with fast skip, raising an unauthorized exception using the <code>throw-unauthorized</code> function.</p>
<pre><code class="clojure">(require '[buddy.auth :refer [authenticated? throw-unauthorized]])
(require '[ring.util.response :refer (response redirect)])

(defn home-controller
  [request]
  (when (not (authenticated? request))
    (throw-unauthorized {:message "Not authorized"}))
  (response "Hello World"))
</code></pre>
<p>Just like the authentication system, authorization is also implemented using plugable backends.</p>
<p>All built-in backends already implement the authorization protocol with default behavior. The default behavior can be overridden passing the <code>:unauthorized-handler</code> option to the backend constructor:</p>
<pre><code class="clojure">(require '[buddy.auth.backends :as backends])
(require '[buddy.auth.middleware :refer [wrap-authentication wrap-authorization]])

;; Simple self defined handler for unauthorized requests.
(defn my-unauthorized-handler
  [request metadata]
  (-&gt; (response "Unauthorized request")
      (assoc :status 403)))

(def backend (backends/basic
              {:realm "API"
               :authfn my-auth-fn
               :unauthorized-handler my-unauthorized-handler}))

(def app (-&gt; your-handler
             (wrap-authentication backend)
             (wrap-authorization backend)))
</code></pre>
<h3><a href="#access-rules" name="access-rules"></a>Access Rules</h3>
<p>The access rules system is another part of authorization. It consists of matching an url to specific access rules logic.</p>
<p>The access rules consist of an ordered list that contains mappings between urls and rule handlers using link:<a href="https://github.com/weavejester/clout[clout">https://github.com/weavejester/clout[clout</a>] url matching syntax or regular expressions.</p>
<pre><code class="clojure">[{:uri "/foo"
  :handler user-access}
</code></pre>
<pre><code class="clojure">[{:uris ["/foo" "/bar"]
  :handler user-access}
</code></pre>
<pre><code class="clojure">[{:pattern #"^/foo$"
  :handler user-access}
</code></pre>
<p>An access rule can also match against certain HTTP methods, by using the <em>:request-method</em> option. <em>:request-method</em> can be a keyword or a set of keywords.</p>
<p>An example of an access rule that matches only GET requests:</p>
<pre><code class="clojure">[{:uri "/foo"
  :handler user-access
  :request-method :get}
</code></pre>
<h4><a href="#rules-handlers" name="rules-handlers"></a>Rules Handlers</h4>
<p>The rule handler is a plain function that accepts a request as a parameter and should return <code>accessrules/success</code> or <code>accessrules/error</code>.</p>
<p>The <code>success</code> is a simple mark that means that handlers pass the validation and <code>error</code> is a mark that means the opposite, that the handler does not pass the validation. Instead of returning plain boolean values, this approach allows handlers to return errors messages or even a ring response.</p>
<p>This is a simple example of the aspect of one rule handler:</p>
<pre><code class="clojure">(require '[buddy.auth.accessrules :refer (success error)])

(defn authenticated-user
  [request]
  (if (:identity request)
    true
    (error "Only authenticated users allowed")))
</code></pre>
<p>These values are considered success marks: <em>true</em> and <em>success</em> instances. These are considered error marks: <em>nil</em>, <em>false</em>, and <em>error</em> instances. Error instances may contain a string as an error message or a ring response hash-map.</p>
<p>Also, a rule handler can be a composition of several rule handlers using logical operators.</p>
<pre><code class="clojure">{:and [authenticated-user other-handler]}
{:or [authenticated-user other-handler]}

;; Logical expressions can be nested as deep as you wish
;; with hypotetical rule handlers with self descriptive name.
{:or [should-be-admin
      {:and [should-be-safe
             should-be-authenticated]}]}}
</code></pre>
<p>This is an example of how a composed rule handler can be used in an access rules list:</p>
<pre><code class="clojure">[{:pattern #"^/foo$"
  :handler {:and [authenticated-user admin-user]}}]
</code></pre>
<p>Additionally, if you are using <em>clout</em> based syntax for matching access rules, the request in a rule handler will contain <code>:match-params</code> with clout matched uri params.</p>
<h4><a href="#usage" name="usage"></a>Usage</h4>
<p>Now, knowing how access rules and rule handlers can be defined, it is time to see how we can use it in our ring applications.</p>
<p><em>buddy-auth</em> exposes two ways to do it:</p>
<ul>
  <li>Using a <em>wrap-access-rules</em> middleware.</li>
  <li>Using a <em>restrict</em> decorator for assigning specific rules handlers to concrete  ring handler.</li>
</ul>
<p>Here are couple of examples of how we could do it:</p>
<pre><code class="clojure">;; Rules handlers used on this example are ommited for code clarity
;; Each handler represents authorization logic indicated by its name.

(def rules [{:pattern #"^/admin/.*"
             :handler {:or [admin-access operator-access]}}
            {:pattern #"^/login$"
             :handler any-access}
            {:pattern #"^/.*"
             :handler authenticated-access}])

;; Define default behavior for not authorized requests
;;
;; This function works like a default ring compatible handler
;; and should implement the default behavior for requests
;; which are not authorized by any defined rule

(defn on-error
  [request value]
  {:status 403
   :headers {}
   :body "Not authorized"})

;; Wrap the handler with access rules (and run with jetty as example)
(defn -main
  [&amp; args]
  (let [options {:rules rules :on-error on-error}
        app     (wrap-access-rules your-app-handler options)]
    (run-jetty app {:port 3000})))
</code></pre>
<p>If a request uri does not match any regular expression then the default policy is used. The default policy in <em>buddy-auth</em> is <em>allow</em> but you can change the default behavior specifying a <code>:reject</code> value in the <code>:policy</code> option.</p>
<p>Additionally, instead of specifying the global <em>on-error</em> handler, you can set a specific behavior on a specific access rule, or use the <em>:redirect</em> option to simply redirect a user to specific url.</p>
<pre><code class="clojure">(def rules [{:pattern #"^/admin/.*"
             :handler {:or [admin-access operator-access]}
             :redirect "/notauthorized"}
            {:pattern #"^/login$"
             :handler any-access}
            {:pattern #"^/.*"
             :handler authenticated-access
             :on-error (fn [req _] (response "Not authorized ;)"))}])
</code></pre>
<p>The access rule options always takes precedence over the global ones.</p>
<p>Then, if you don’t want an external rules list and simply want to apply some rules to specific ring views/handlers, you can use the <code>restrict</code> decorator. Let’s see it in action:</p>
<pre><code class="clojure">(require '[buddy.auth.accessrules :refer [restrict]])

(defn home-controller
  [request]
  {:body "Hello World" :status 200})

(defroutes app
  (GET "/" [] (restrict home-controller {:handler should-be-authenticated
                                         :on-error on-error}))
</code></pre>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<h3><a href="#http-basic-auth-example" name="http-basic-auth-example"></a>Http Basic Auth Example</h3>
<p>This example tries to show the way to setup http basic auth in a simple ring based application.</p>
<p>Just run the following commands:</p>
<pre><code>git clone https://github.com/funcool/buddy-auth.git
cd ./buddy-auth/
lein with-profile +httpbasic-example run
</code></pre>
<p>And redirect your browser to <a href="http://localhost:3000/">http://localhost:3000/</a>.</p>
<p>The credentials are: <code>admin</code> / <code>secret</code> and <code>test</code> / <code>secret</code>.</p>
<p>You can see the example code here: <a href="https://github.com/funcool/buddy-auth/tree/master/examples/httpbasic">https://github.com/funcool/buddy-auth/tree/master/examples/httpbasic</a></p>
<h3><a href="#session-auth-example" name="session-auth-example"></a>Session Auth Example</h3>
<p>This example tries to show the way to setup session based auth in a simple ring based application.</p>
<p>Just run the following commands:</p>
<pre><code>git clone https://github.com/funcool/buddy-auth.git
cd ./buddy-auth/
lein with-profile +session-example run
</code></pre>
<p>And redirect your browser to <a href="http://localhost:3000/">http://localhost:3000/</a>.</p>
<p>The credentials are: <code>admin</code> / <code>secret</code> and <code>test</code> / <code>secret</code>.</p>
<p>You can see the example code here: <a href="https://github.com/funcool/buddy-auth/tree/master/examples/session">https://github.com/funcool/buddy-auth/tree/master/examples/session</a></p>
<h3><a href="#token-auth-example" name="token-auth-example"></a>Token Auth Example</h3>
<p>This example tries to show the way to setup token based auth in a simple ring based application.</p>
<p>Just run the following commands:</p>
<pre><code>git clone https://github.com/funcool/buddy-auth.git
cd ./buddy-auth/
lein with-profile +token-example run
</code></pre>
<p>You can use <em>curl</em> for play with the authentication example:</p>
<pre><code>$ curl -v -X POST -H "Content-Type: application/json" -d '{"username": "admin", "password": "secret"}' http://localhost:3000/login
* Connected to localhost (::1) port 3000 (#0)
&gt; POST /login HTTP/1.1
&gt; Host: localhost:3000
&gt; User-Agent: curl/7.46.0
&gt; Accept: */*
&gt; Content-Type: application/json
&gt; Content-Length: 43
&gt;
* upload completely sent off: 43 out of 43 bytes
&lt; HTTP/1.1 200 OK
&lt; Date: Mon, 04 Jan 2016 13:54:02 GMT
&lt; Content-Type: application/json; charset=utf-8
&lt; Content-Length: 44
&lt; Server: Jetty(9.2.10.v20150310)
&lt;
* Connection #0 to host localhost left intact
{"token":"fe562338bf1604bd175722e32a4d7115"}
</code></pre>
<pre><code>$ curl -v -X GET -H "Content-Type: application/json" -H "Authorization: Token fe562338bf1604bd175722e32a4d7115" http://localhost:3000/
* Connected to localhost (::1) port 3000 (#0)
&gt; GET / HTTP/1.1
&gt; Host: localhost:3000
&gt; User-Agent: curl/7.46.0
&gt; Accept: */*
&gt; Content-Type: application/json
&gt; Authorization: Token fe562338bf1604bd175722e32a4d7115
&gt;
&lt; HTTP/1.1 200 OK
&lt; Date: Mon, 04 Jan 2016 13:54:40 GMT
&lt; Content-Type: application/json; charset=utf-8
&lt; Content-Length: 55
&lt; Server: Jetty(9.2.10.v20150310)
&lt;
* Connection #0 to host localhost left intact
{"status":"Logged","message":"hello logged user:admin"}
</code></pre>
<p>You can see the example code here: <a href="https://github.com/funcool/buddy-auth/tree/master/examples/token">https://github.com/funcool/buddy-auth/tree/master/examples/token</a></p>
<h3><a href="#jwe-token-auth-example" name="jwe-token-auth-example"></a>JWE Token Auth Example</h3>
<p>This example tries to show the way to setup jwe stateless token based auth in a simple ring based application.</p>
<p>Just run the following commands:</p>
<pre><code>git clone https://github.com/funcool/buddy-auth.git
cd ./buddy-auth/
lein with-profile +jwe-example run
</code></pre>
<p>You can use <em>curl</em> for play with the authentication example:</p>
<pre><code>$ curl -v -X POST -H "Content-Type: application/json" -d '{"username": "admin", "password": "secret"}' http://localhost:3000/login
* Connected to localhost (::1) port 3000 (#0)
&gt; POST /login HTTP/1.1
&gt; Host: localhost:3000
&gt; User-Agent: curl/7.46.0
&gt; Accept: */*
&gt; Content-Type: application/json
&gt; Content-Length: 43
&gt;
* upload completely sent off: 43 out of 43 bytes
&lt; HTTP/1.1 200 OK
&lt; Date: Mon, 04 Jan 2016 13:52:11 GMT
&lt; Content-Type: application/json; charset=utf-8
&lt; Content-Length: 189
&lt; Server: Jetty(9.2.10.v20150310)
&lt;
* Connection #0 to host localhost left intact
{"token":"eyJhbGciOiJBMjU2S1ciLCJ0eXAiOiJKV1MiLCJlbmMiOiJBMTI4R0NNIn0.Q672y_lD3bOU_qm5U0RDKS-YszRHfkFu.vDZaAJPz8uL5q1A4.LonJtHZMA_Ty53YBmr1zpE7-SIbTJgVgme--Tjj25dHN.goYEyM3JZgYlbARo8CDk0g"}
</code></pre>
<p>Perform an authenticated request (using previously obtained token):</p>
<pre><code>$ curl -v -X GET -H "Content-Type: application/json" -H "Authorization: Token eyJhbGciOiJBMjU2S1ciLCJ0eXAiOiJKV1MiLCJlbmMiOiJBMTI4R0NNIn0.Q672y_lD3bOU_qm5U0RDKS-YszRHfkFu.vDZaAJPz8uL5q1A4.LonJtHZMA_Ty53YBmr1zpE7-SIbTJgVgme--Tjj25dHN.goYEyM3JZgYlbARo8CDk0g" http://localhost:3000/
* Connected to localhost (::1) port 3000 (#0)
&gt; GET / HTTP/1.1
&gt; Host: localhost:3000
&gt; User-Agent: curl/7.46.0
&gt; Accept: */*
&gt; Content-Type: application/json
&gt; Authorization: Token eyJhbGciOiJBMjU2S1ciLCJ0eXAiOiJKV1MiLCJlbmMiOiJBMTI4R0NNIn0.Q672y_lD3bOU_qm5U0RDKS-YszRHfkFu.vDZaAJPz8uL5q1A4.LonJtHZMA_Ty53YBmr1zpE7-SIbTJgVgme--Tjj25dHN.goYEyM3JZgYlbARo8CDk0g
&gt;
&lt; HTTP/1.1 200 OK
&lt; Date: Mon, 04 Jan 2016 13:52:59 GMT
&lt; Content-Type: application/json; charset=utf-8
&lt; Content-Length: 84
&lt; Server: Jetty(9.2.10.v20150310)
&lt;
* Connection #0 to host localhost left intact
{"status":"Logged","message":"hello logged user {:user \"admin\", :exp 1451919131}"}
</code></pre>
<p>You can see the example code here: <a href="https://github.com/funcool/buddy-auth/tree/master/examples/jwe">https://github.com/funcool/buddy-auth/tree/master/examples/jwe</a></p>
<h3><a href="#signed-jwt-auth-example" name="signed-jwt-auth-example"></a>Signed JWT Auth Example</h3>
<p>This example tries to show the way to setup jws stateless token based auth in a simple ring based application.</p>
<p>Just run the following commands:</p>
<pre><code>git clone https://github.com/funcool/buddy-auth.git
cd ./buddy-auth/
lein with-profile +jws-example run
</code></pre>
<p>You can use <em>curl</em> for play with the authentication example:</p>
<pre><code>$ curl -v -X POST -H "Content-Type: application/json" -d '{"username": "admin", "password": "secret"}' http://localhost:3000/login
&gt; POST /login HTTP/1.1
&gt; Host: localhost:3000
&gt; User-Agent: curl/7.46.0
&gt; Accept: */*
&gt; Content-Type: application/json
&gt; Content-Length: 43
&gt;
* upload completely sent off: 43 out of 43 bytes
&lt; HTTP/1.1 200 OK
&lt; Date: Mon, 04 Jan 2016 13:49:30 GMT
&lt; Content-Type: application/json; charset=utf-8
&lt; Content-Length: 180
&lt; Server: Jetty(9.2.10.v20150310)
&lt;
* Connection #0 to host localhost left intact
{"token":"eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXUyJ9.eyJ1c2VyIjoiYWRtaW4iLCJleHAiOjE0NTE5MTg5NzB9.Kvpr1jW7JBCZYUlFjAf7xnqMZSTpSVggAgiZ6_RGZuTi1wUuP_-E8MJff23GuCwpT9bbbHNTk84uV2cdg7rKTw"}
</code></pre>
<p>Perform an authenticated request (using previously obtained token):</p>
<pre><code>$ curl -v -X GET -H "Content-Type: application/json" -H "Authorization: Token eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXUyJ9.eyJ1c2VyIjoiYWRtaW4iLCJleHAiOjE0NTE5MTg5NzB9.Kvpr1jW7JBCZYUlFjAf7xnqMZSTpSVggAgiZ6_RGZuTi1wUuP_-E8MJff23GuCwpT9bbbHNTk84uV2cdg7rKTw" http://localhost:3000/
* Connected to localhost (::1) port 3000 (#0)
&gt; GET / HTTP/1.1
&gt; Host: localhost:3000
&gt; User-Agent: curl/7.46.0
&gt; Accept: */*
&gt; Content-Type: application/json
&gt; Authorization: Token eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXUyJ9.eyJ1c2VyIjoiYWRtaW4iLCJleHAiOjE0NTE5MTg5NzB9.Kvpr1jW7JBCZYUlFjAf7xnqMZSTpSVggAgiZ6_RGZuTi1wUuP_-E8MJff23GuCwpT9bbbHNTk84uV2cdg7rKTw
&gt;
&lt; HTTP/1.1 200 OK
&lt; Date: Mon, 04 Jan 2016 13:50:15 GMT
&lt; Content-Type: application/json; charset=utf-8
&lt; Content-Length: 84
&lt; Server: Jetty(9.2.10.v20150310)
&lt;
* Connection #0 to host localhost left intact
{"status":"Logged","message":"hello logged user {:user \"admin\", :exp 1451918970}"}
</code></pre>
<p>You can see the example code here: <a href="https://github.com/funcool/buddy-auth/tree/master/examples/jws">https://github.com/funcool/buddy-auth/tree/master/examples/jws</a></p>
<h2><a href="#faq" name="faq"></a>FAQ</h2>
<p><em>What is the difference with Friend?</em></p>
<p><em>buddy-auth</em> authorization/authentication facilities are more low level and less opinionated than friend, and allow you to easily build other high level abstractions over them. Technically, friend abstraction can be built on top of <em>buddy-auth</em>.</p>
<p>*How can I use <em>buddy</em> with link:<a href="http://clojure-liberator.github.io/liberator/[liberator]?*">http://clojure-liberator.github.io/liberator/[liberator]?*</a></p>
<p>By design, <em>buddy</em> has authorization and authentication well separated. This helps a lot if you want use only one part of it (ex: authentication only) without including the other.</p>
<p>In summary: yes, you can use <em>buddy-auth</em> with liberator.</p>
<p><em>Can I use <em>buddy-auth</em> with pedestal?</em></p>
<p>Although is not mentioned in this documentation, you can use <em>buddy-auth</em> with pedestal without any problems.</p>
<p><a href="https://juxt.pro/blog/posts/securing-your-clojurescript-app.html">https://juxt.pro/blog/posts/securing-your-clojurescript-app.html</a></p>
<p><em>Can I use <em>buddy-auth</em> with catacumba?</em></p>
<p>Not directly.</p>
<p>The design of <em>buddy-auth</em> api is intrinsically blocking just because ring and ring based abstractions are also blocking. However <em>catacumba</em> is asyncronous toolkit and it comes with its own, builtint variant of <em>buddy-auth</em> designed for asynchronous workflow (reusing the underlying <em>buddy-sign</em>, <em>buddy-core</em> and <em>buddy-hashers</em> modules).</p>
<h2><a href="#developers-guide" name="developers-guide"></a>Developers Guide</h2>
<h3><a href="#contributing" name="contributing"></a>Contributing</h3>
<p>Unlike Clojure and other Clojure contributed libraries <em>buddy-auth</em> does not have many restrictions for contributions. Just open an issue or pull request.</p>
<h3><a href="#philosophy" name="philosophy"></a>Philosophy</h3>
<p>Five most important rules:</p>
<ul>
  <li>Beautiful is better than ugly.</li>
  <li>Explicit is better than implicit.</li>
  <li>Simple is better than complex.</li>
  <li>Complex is better than complicated.</li>
  <li>Readability counts.</li>
</ul>
<p>All contributions to <em>buddy-auth</em> should keep these important rules in mind.</p>
<h3><a href="#get-the-code" name="get-the-code"></a>Get the Code</h3>
<p><em>buddy-auth</em> is open source and can be found on link:<a href="https://github.com/funcool/buddy-auth[github]">https://github.com/funcool/buddy-auth[github]</a>.</p>
<p>You can clone the public repository with this command:</p>
<pre><code>git clone https://github.com/funcool/buddy-auth
</code></pre>
<h3><a href="#run-tests" name="run-tests"></a>Run tests</h3>
<p>For running tests just execute this:</p>
<pre><code class="bash">lein test
</code></pre>
<h3><a href="#license" name="license"></a>License</h3>
<p><em>buddy-auth</em> is licensed under Apache 2.0 License. You can see the complete text of the license on the root of the repository on <code>LICENSE</code> file.</p></div></div></div></body></html>